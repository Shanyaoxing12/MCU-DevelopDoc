# **UG103.3：Application Development Fundamentals：Design Choices** <!-- omit in toc -->

本文档从如何构建无线网络解决方案的主要决策方面描述了应用程序设计过程。

Silicon Labs 的应用程序开发基础系列涵盖了项目经理，应用程序设计人员和开发人员在开始使用 Silicon Labs 芯片，EmberZNet PRO 或 Silicon Labs Bluetooth Smart 等网络栈以及相关开发工具的嵌入式网络解决方案之前应该了解的主题。这些文档可以作为任何需要介绍开发无线网络应用程序的人或者是 Silicon Labs 开发环境的新手的起点。

关键点：
* 使用哪个栈或应用程序框架？
* SoC 还是 NCP？
* Zigbee 设计选择

------------------------------------------------------------------------------------------------------------------------

- [**1. 背景**](#1-背景)
- [**2. 一般设计选择**](#2-一般设计选择)
    - [**2.1 你应该使用哪种无线协议**](#21-你应该使用哪种无线协议)
    - [**2.2 SoC 还是 NCP？**](#22-soc-还是-ncp)
        - [**2.2.1 SoC 方案**](#221-soc-方案)
        - [**2.2.2 带串行协议的 NCP 方案**](#222-带串行协议的-ncp-方案)
        - [**2.2.3 设计上的差异**](#223-设计上的差异)
- [**3. Zigbee 设计选择**](#3-zigbee-设计选择)
    - [**3.1 单网络与多网络对比**](#31-单网络与多网络对比)
        - [**3.1.1 协调器/路由器 网络 + 嗜睡终端设备网络**](#311-协调器路由器-网络--嗜睡终端设备网络)
        - [**3.1.2 多个嗜睡终端设备网络**](#312-多个嗜睡终端设备网络)
    - [**3.2 网络 发现/试运行**](#32-网络-发现试运行)
        - [**3.2.1 通过扩展 PAN ID 或信道掩码简化网络选择**](#321-通过扩展-pan-id-或信道掩码简化网络选择)
        - [**3.2.2 许可加入控制**](#322-许可加入控制)

------------------------------------------------------------------------------------------------------------------------

# **1. 背景**

Silicon Labs 正在开发满足客户需求的产品，因为我们正在进入一个家庭中设备一直连接的世界，通常被称为物联网（IoT）。在高层次上，Silicon Labs 物联网的目标是：
* 无论是 Zigbee PRO，Thread，Bluetooth Smart 还是其他新兴标准，都可以通过一流的网络连接家中的所有设备。
* 利用公司在节能微控制器方面的专业知识。
* 增强现有的低功耗，混合信号芯片。
* 实现云服务和与智能手机和平板电脑的连接，促进易用性和为客户提供通用的用户体验。

实现所有的这些目标将提高联网家庭中物联网设备的采用率和用户接受度。

随着应用程序设计人员可用选项的范围增加，早期设计选择的影响也会增加。本文档从如何构建无线网络解决方案的主要决策方面描述了应用程序设计过程。基本设计选择包括：
* 使用哪种 Silicon Labs 无线技术
* 是使用 SoC（片上系统）设计还是 NCP（网络协处理器）设计
* 如果使用 NCP 模型，如何选择兼容的 NCP 和主机应用程序

开发 Zigbee 解决方案时的设计选择包括：
* 如何创建网络（形成，加入或离开）
* 将使用哪些安全模型
* 在网络中采用哪种路由优化
* 如何通过网络传递消息

一旦考虑了这些选择，就可以开始实施系统设计了。

------------------------------------------------------------------------------------------------------------------------

# **2. 一般设计选择**

在开始使用 Silicon Labs 的无线微控制器进行无线设计之前，您应该首先考虑哪种可用的网络技术最适合您的项目。一旦确定了要用于设计的网络协议，请考虑您的产品最适合片上系统（SoC）范例或是网络协处理器（NCP）范例，对于 NCP，用于控制协处理器的串行通信是什么类型的。

## **2.1 你应该使用哪种无线协议**

Silicon Labs 提供以下用于 Wireless Gecko family 开发的栈：
* Silicon Labs Flex SDK，包括基于 IEEE 802.15.4 的 “Connect” 栈（在 **UG103.12：Application Development Fundamentals：Silicon Labs Connect** 中描述）以用于多跳 “星形” 网络拓扑，以及用于具有自定义 RF 配置的真正专有设计的无线电抽象接口库（RAIL）。
* EmberZNet，一个基于 Zigbee PRO 的网状网络栈，在 **UG103.2：Application Development Fundamentals：Zigbee** 中详细描述。
* Silicon Labs Thread，一个基于 Thread 1.1 的 IPv6 网状网络栈，在 **UG103.11：Application Development Fundamentals：Thread** 中详细描述。
* Silicon Labs Bluetooth SDK，一个 Bluetooth 2.3-based 的网络栈，在 **UG103.14：Application Development Fundamentals：Bluetooth Smart Technology** 中详细描述。

熟悉这些协议的详细信息后，您可以根据自己对标准合规性、网络拓扑、互操作性、频率范围和消息吞吐量的需求进行选择。

## **2.2 SoC 还是 NCP？**

无论您是否使用应用程序框架进行设计，选择 SoC（片上系统）模型或 NCP（串行网络协处理器）模型的设计范例都是一个关键问题。它规定了软件和硬件的要求和约束。这个选择决定了应用程序相对于核心栈功能所在的位置。在 SoC 模型中，整个系统（栈和应用程序）在一个单独的芯片上；而在 NCP 模型中，栈处理在一个单独的 “协处理器” 中完成，该协处理器通过外部串行接口与应用程序自己的微控制器交互。

下图说明了栈和应用程序的各种组件以及它们如何相对于 SoC 或 NCP 架构模型进行组织。

![Figure 2.1. Stack and Application Component Organization in SoC and NCP Architectures](../Pic/Application%20Development%20Fundamentals-Design%20Choices-F2.1.jpg)

虽然不能轻易地在架构之间做出选择，但应用程序框架在某种程度上掩盖了差异，在必要时简化了从一个架构到另一个架构的更改，或支持不同产品的混合架构。

### **2.2.1 SoC 方案**

在 SoC 方案中，单个芯片（如 Wireless Gecko（EFR32™）产品组合中的一个 IC）提供了所有栈功能（包括集成 flash，RAM 和 RF 收发器）以及应用层组件（应用配置文件，簇，属性管理和栈交互）。栈功能是以预编译库文件的形式实现，然后您必须将其在最终构建过程中与您自己的应用程序相关的代码链接起来，以生成单片包含完整功能的无线应用程序所需的所有内容的二进制映像。应用程序框架虽然由 Silicon Labs 提供，但仍被视为应用层的一部分。

> Note：虽然 bootloader 通常用于已部署的无线网络设备，但 bootloader 固件并非此单片二进制映像的一部分。然而，Silicon Labs 确实提供了构建后（post-build）工具，可用于将应用程序固件和栈固件进一步组合到单个 HEX 记录文件中，以便于分发和制造。有关 EmberZNet PRO 应用程序的这些软件的实用程序的更多信息，请参阅文档 **UG107：EM3x Utilities Guide**，**UG162：Simplicity Commander Reference Guide** 和 **UG103.6：Application Development Fundamentals：Bootloading**。

在 SoC 开发方案中，应用程序（包括应用程序框架）与栈共存。应用程序调用栈库提供的 API（应用程序编程接口函数），并且栈触发应用程序代码实现的处理程序函数。当应用程序框架用于应用程序设计时，框架会处理调用这些 API 并实现必要的处理程序函数，然后将它们包含在更高级别的 API 和应用程序回调中，以简化设计过程并帮助确保协议合规性。

由于 SoC 模型仅需要单个芯片，因此与需要多个 IC 的 NCP 模型和传统设计架构相比，SoC 模型具有更低的功耗，更低的 BOM（物料清单）成本以及更小的可能布局。此外，当所有内容都驻留在单个芯片上时，可以实现与栈软件和无线电硬件的更紧密集成，从而允许更精确和及时地控制与栈活动相关的应用程序行为。

然而，一旦您致力于 SoC 模型，您就会受到该 SoC 系列中可用产品的约束。其中包括：
* Flash 和 RAM 存储约束
* 工具链约束，如需要为基于 Zigbee 和基于 Thread 的 SoC 使用 IAR Embedded Workbench
* HAL 约束，如某种类型的外围设备数量有限，或缺少可能与硬件设计不可或缺的专用外设
* 基于必须与栈共享 CPU 的时序约束，该栈具有自己的一组要求，以便维护 IEEE 802.15.4 和协议合规性

如果这些约束中的任何一个都对你有很大的阻碍，那么 NCP 模型可能是更具吸引力的替代方案。

### **2.2.2 带串行协议的 NCP 方案**

> Note：本节不适用于蓝牙 SoC 或 NCP 模型。有关更多信息，请参阅 **AN1042：Using the Silicon Labs Bluetooth® Stack in Network Co-Processor Mode** 和 **UG136：Silicon Labs Bluetooth® C Application Developer's Guide**。

在 NCP 方案中，带有集成 flash，RAM 和 RF 收发器的 Silicon Labs 芯片通过预加载的协处理器固件自行运行大多数的栈功能，并具有运行时可配置性，然后使用一个串行接口，如串行外设接口（SPI）或通用异步 接收/发送 器（UART）与第二个设备（称为 “主机” 处理器）通信，其中应用层功能与核心栈组件分开 “托管”。NCP 可能是一种特殊的集成电路，具有有限的 I/O 和简化的功能，目的是作为协处理器，或者它可能是一个功能齐全的微控制器，恰好将协处理器固件加载到其上，使其表现为 NCP。

为了方便应用程序主机和栈的 NCP 之间的通信，Silicon Labs 提供了两种串行命令集。第一种称为 EZSP（EmberZNet 串行协议），用于开发 Zigbee 解决方案（有关 EZSP 的更多信息，请参阅文档 **UG100：EZSP Reference Guide**）。第二种称为 Thread 管理串行协议（TMSP），用于开发 Thread 解决方案。Silicon Labs Flex SDK 中的 Silicon Labs Connect 栈也提供 NCP 解决方案，用于专有开发。

EZSP 可以在 SPI 上同步运行或在 UART 上异步运行（带或不带流量控制），其使用 EZSP 特定命令帧（有时可能与 EmberZNet 中基于 SoC 的对应部分略有不同）模拟 EmberZNet PRO API 并使用回调响应帧模拟 EmberZNet 相关的处理函数。Silicon Labs 提供了 EZSP 驱动程序源代码，将这些串行命令和响应抽象为一组 API 和处理函数，类似于 SoC 模型中使用的那些。当应用程序框架用于实现应用层时，它负责调用必要的 API 函数并实现所需的处理函数，从而允许设计人员专注于使用客户端 API 和框架回调进行更高级别的应用程序处理。

在 TMSP 协议中，也提供 SPI 和 UART 变体，主机端 API 不是与基于 SoC 的 Thread 应用程序使用的 API “相似” 的专用函数。相反，它们（由提供的 TMSP 驱动程序代码处理的主机端接口的抽象）实际上与基于 SoC 的系统上使用的 API 和回调相同。此外，TMSP 驱动程序包含一些功能以管理 NCP 上的底层 IP 层，以改善在 NCP 及其主机上共享的栈的上层之间的协调。

NCP 平台的主要优势在于其灵活性。主机处理器可以像 8 位微控制器一样简单，也可以像具有千兆字节的内存和 Windows 或 Linux 操作系统的 64 位计算机一样复杂。这意味着 NCP 设计非常适合在现有系统上添加或改造一个设备的场景，这样可以利用 OEM 在软件和硬件方面的专业知识和知识产权来加速设计周期和加快上市时间。NCP 方案的另一个优点是，与可用的 SoC 选项相比，主机可以为应用程序提供更多的资源（flash 和 RAM）和不同的外设集。这允许使用新特性开发更复杂的应用程序，并在应用程序中添加重要的新特性时保护应用程序不会超出 SoC 的限制。

通过将栈处理与应用程序解耦，可以在栈端安装修复程序和新特性，只需对 NCP 进行简单的固件更新，而无需对主机上的应用程序固件进行任何更改。这种解耦还消除了与栈共享处理器的 CPU 时序限制。由于 NCP 固件管理 NCP 的睡眠状态以最小化其活动和当前消耗，因此当应用程序具有不直接涉及栈的任务时，仅需要主机处理器处于活动状态。如果在没有无线电的情况下，当 CPU 处于活动状态时，主机处理器的有效电流消耗低于 SoC 的有效电流消耗，那么运行非网络应用任务时主机和 NCP 消耗的总电流实际上可能低于可比较的 SoC 场景。

NCP 方案的主要缺点是增加了第二个主机处理器，这增加了额外的成本和 PCB 空间，并可能影响设备的总体功耗。另一个权衡是解耦栈和应用程序处理意味着栈和应用程序之间的某些时间敏感的交互不再能够 “实时” 发生，而必须以通知的形式，以通知栈在事后做出决策。因此，主机应用程序在某些决策出现时确定其结果的机会变少。相反，在 NCP 上配置 “策略” 以指导这些情况下的栈行为。此外，由于 NCP 固件是 Silicon Labs 提供的预构建固件，因此应用程序设计人员会对栈的行为以及内部资源的分配失去一定程度的控制。

一旦您致力于使用 NCP 方案，您就必须决定使用哪个主机平台进行设计。该平台可能与原型和最终设计阶段不同，具体取决于材料的可用性和调试初始阶段所需的灵活性。在选择主机平台时，请考虑您在该平台上的现有专业知识、可用工具和资源，该平台的成本和功耗要求，以及可用于应用程序开发的内存量，包括未来增强所需的任何空间。在开发 Zigbee 解决方案时，还应考虑是否使用 UART 或 SPI 进行 EZSP 通信。EZSP-UART 需要一个更复杂的驱动程序，通常用于兼容 POSIX 标准的操作系统，其比 EZSP-SPI 驱动程序具有更复杂的逻辑和更大的内存占用，并且其支持的最大吞吐量不是很高。但是，EZSP-SPI 实现比 EZSP-UART 设计需要更多的接口引脚（用于 EZSP 的可移植操作系统接口（POSIX）的 SPI 驱动程序也是可用的，但在嵌入式 Linux 操作系统上的可移植性通常低于兼容 POSIX 标准的 UART 驱动程序）。由于并非所有微控制器或操作系统都支持 SPI，因此主机的架构限制可能决定了选择哪种设计。Thread 的 TMSP 对 SPI 和 UART 也有类似的权衡。有关设置 Thread 主机 SPI 驱动程序的更多讨论，请参见 **AN912：SPI Host Interfacing Guide for Thread**。

### **2.2.3 设计上的差异**

> Note：本节不适用于蓝牙 SoC 或 NCP 模型。有关更多信息，请参阅 **AN1042：Using the Silicon Labs Bluetooth® Stack in Network Co-Processor Mode** 和 **UG136：Silicon Labs Bluetooth® C Application Developer's Guide**。

下表按功能显示了 SoC 应用程序与基于 NCP 的主机应用程序之间的一些主要差异。

![Table 2.1. Functional Differences, SoC compared with NCP](../Pic/Application%20Development%20Fundamentals-Design%20Choices-T2.1.jpg)

![Table 2.1. Functional Differences, SoC compared with NCP](../Pic/Application%20Development%20Fundamentals-Design%20Choices-T2.1c.jpg)

------------------------------------------------------------------------------------------------------------------------

# **3. Zigbee 设计选择**

尽管应用程序框架简化并抽象了设计过程，但无论设计是否基于应用程序框架，都必须将某些设计决策作为实现的一部分。在开发 Zigbee 协议的应用程序时，以下设计选择是适用的，包括 Zigbee PRO 和 Zigbee RF4CE：
* 单网络或多网络(Single Network or Multi-Network)
* 网络 发现/试运行 方法(Network Discovery/Commissioning Method)
* 设备发现和供应方法(Device Discovery and Provisioning Method)
* 路由建立方法(Route Establishment Method)
* 消息传递方法(Message Delivery Method)
* NCP 和主机应用程序兼容性(NCP and Host Application Compatibility)

## **3.1 单网络与多网络对比**

单个网络节点是一个形成或加入一个网络的节点，必须在形成或加入第二个网络之前离开该网络。EmberZNet PRO 4.7 引入了一个节点同时成为多个网络的一部分的可能性（EM351 不支持此特性）。

> Note：对于 EmberZNet PRO，多网络支持仅限于两个网络。将来可能会支持两个以上的网络。

到目前为止，任何设备都需要两个物理芯片才能成为两个网络的一部分。例如，设计为 HA（家庭自动化）PAN（个人区域网络）和 SE（智能能源）PAN 之间的网关的设备将使用第一个芯片加入第一个网络，使用第二个芯片加入第二个网络。应用程序必须管理两个硬件，导致硬件和应用程序设计人员的工作复杂性增加。

多网络栈消除了逻辑 PAN 和物理芯片之间的 1 对 1 映射，将其扩展为 n 对 1 映射。具有单个芯片的设备的应用程序可以被设计为可能运行不同安全配置文件的多个 PAN 的一部分（例如 HA 和 SE）。使用一个而不是两个芯片可以降低硬件要求并降低硬件和应用程序代码设计的复杂性，从而节省成本。

某些应用程序仍需要双芯片配置。如果设备需要成为两个网络上的协调器或路由器（请参阅下面的详细信息），或者应用程序需要在两个不同的栈（如 EmberZNet PRO 和 Silicon Labs Thread）上运行，则需要此配置。

单个芯片上的多网络是通过对网络上芯片唯一无线电的分时实现的。换句话说，多网络的节点根据网络调度算法重置网络之间的所有无线电参数。

事实上节点在多个网络上同时活动是对应用程序完全透明的。API 允许应用程序指定引用 API 调用的网络集。类似地，API 允许应用程序了解栈回调与哪个网络相关。有关双网络 API 的更多详细信息，请参阅文档 **AN724：Designing for Multiple Networks on a Single Chip**。

AFV2 和网络协处理器应用框架都提供了双网络支持。我们强烈建议在开发双网络应用程序时使用应用程序框架。应用程序框架在降低复杂性方面提供了许多优势，主要是与框架如何无缝地管理不同的网络上下文有关。

通常，当需要在特定网络上发送传出数据包时，多网络栈切换网络或调谐无线电到不同的网络上。在非传输时间期间，无线电始终根据栈的内部网络调度算法调谐到其中一个网络上。

节点可以在网络上假定的角色存在一些限制。由于协调器或路由器节点被期望始终保持无线电以监听传入的数据包，因此多网络节点只能在一个网络上是协调器或路由器，而在其他网络上它必须是嗜睡终端设备。

> Note：节点可以在一个网络上假定为任何角色，但必须在其他网络上为一个嗜睡终端设备。

节点参与的网络可以有不同的信道，不同的 PAN ID，不同的短 ID，不同的配置文件等。然而，一个多网络节点在其参与的网络中维护相同的 EUI64 地址。下一节将更详细地讨论两种基本配置，第一种是多网络节点在一个网络上为协调器或路由器，在所有其他网络上为嗜睡终端设备；第二种是在所有网络上都为嗜睡终端设备。

### **3.1.1 协调器/路由器 网络 + 嗜睡终端设备网络**

作为一个网络上的 协调器/路由器 和其他网络上的嗜睡终端设备的多网络节点应该将大部分时间花在 协调器/路由器 网络上。网络调度算法负责无缝地从一个网络切换到另一个网络，使得节点总是在 协调器/路由器 网络上，除了短暂周期的时间。特别地，节点临时离开 协调器/路由器 网络以完成在嗜睡终端设备网络上的某些事务，例如从父节点检索 轮询/数据 和/或 发送数据到父节点。这些事务通常在应用层发起。因此，应用程序设计人员应该设计应用程序，以使节点不会离开 协调器/路由器 网络太长时间。多网络节点在嗜睡终端设备网络上过于繁忙会持续地影响节点的吞吐量，并且通常会延迟在 协调器/路由器 网络上通过该节点路由的所有流量。

在文档 **AN724：Designing for Multiple Networks on a Single Chip** 中，Silicon Labs 提供了从广泛实验中获得的数据，这些数据显示了典型的轮询和数据事务在嗜睡终端设备与其父设备之间的平均持续时间。该文档还包括了嗜睡终端设备网络上的活动如何影响 协调器/路由器 网络上的吞吐量的详细研究。利用这些数据，您可以根据多网络节点在嗜睡终端设备网络上处理的流量以及此流量如何影响 协调器/路由器 网络的性能，进行有根据的设计选择。

请注意，即使节点在大多数网络上充当嗜睡终端设备，如果它也是任何一个网络上的 协调器/路由器，它将无法通过暂时关闭无线电来节能（睡眠模式）。

### **3.1.2 多个嗜睡终端设备网络**

在所有网络上作为嗜睡终端设备的多网络节点不需要始终保持打开其无线电。节点可以在每个网络上以不同的轮询速率进行轮询。只要任何网络上没有活动，节点就能够睡眠。

## **3.2 网络 发现/试运行**

试运行（Commissioning）是指使设备进入网络的过程。如果您已阅读文档 **UG103.2：Application Development Fundamentals：Zigbee** 中有关网络加入过程的讨论，您可能还记得，除非设备充当 PAN 的协调器，否则它必须请求加入现有的网络，并且加入设备必须扫描一个或多个信道以定位可用的网络。然而，由于网络协调器有多个无线电信道可供选择，以形成其 PAN，并且由于网络的 PAN ID 和 扩展 PAN 通常是随机的，因此您的应用程序通常需要一些智能或外部机制来协助网络发现和试运行。这任务包括帮助确保设备可以加入合适的网络或从某些外部源接收所需的网络设置，并确保当错误地加入到错误的网络或设备正在迁移到新的安装时可以从网络中移除设备。同样，如果您正在设计一个可充当 Zigbee PAN 协调器的设备，则必须重点考虑如何为希望进入您的协调器网络的设备简化网络选择的过程。

> Note：如果您正在设计一个用于官方公共 Zigbee PRO 应用程序配置文件（如家庭自动化）的应用程序，Silicon Labs 建议您查看您所设计的目标的相应 Zigbee 应用程序配置文件规范的最新发布版本（从 http://www.zigbee.org 中获取），以确保其符合任何配置文件特定的要求或试运行的最佳实践。

### **3.2.1 通过扩展 PAN ID 或信道掩码简化网络选择**

虽然 PAN 协调器选择的扩展 PAN ID 通常是随机的，但是专有网络的部署可以使用扩展 PAN ID 的特定位掩码作为加入设备的增强网络选择的一种方式。在该模型中，协调器在该商定的扩展 PAN ID 掩码内形成网络，这样加入设备就可以扫描信道以打开 PAN 并限制那些超出所配置的扩展 PAN ID 范围的信道。然而，对于希望在公共 Zigbee PRO 配置文件上与众多制造商的设备进行互操作的设备来说，这种增强网络选择的方法是并不可行。由于公共 Zigbee PRO 应用程序配置文件通常不限制其扩展 PAN ID 选择，因此另一个供应商的设备可能会占用您所选择的限制位掩码之外的扩展 PAN ID。

类似地，尽管 2.4GHz Zigbee 网络可以占用 16 个不同信道中的任何一个，但是加入设备可能能够限制其信道掩码以扫描。预期的网络可能是一个专有的设计，该设计中协调器选择将其信道选择限制在预配置的掩码中的几个信道。或者，所包括设备的一个或多个端点所基于的应用配置文件可能需要将网络的信道选择约束到特定的一组信道上。例如，Zigbee PRO SE 和 HA 应用配置文件都要求在形成网络时优先考虑在最常用的 Wi-Fi 信道（IEEE802.11 范围内的信道 1, 6 和 11）之外的信道，其允许加入设备将其信道扫描限制在 Zigbee 信道 11, 14, 15, 19, 20, 24 和 25 上。注意，AFV2 使用 Network Find 插件（如果启用）在设备加入或形成一个网络时配置设备的信道掩码。如果使用 Application Builder 配置应用程序，请确保在 Network Find 插件的配置对话框中查看 Channel Mask 和其他无线电参数设置。如果您没有使用 Network Find 插件或您的应用程序不是基于 AFV2，那么您的应用程序代码需要使用自己的方法来确保在扫描，加入或形成网络期间强制执行首选信道掩码和任何其他首选网络参数。

### **3.2.2 许可加入控制**

希望加入网络的设备通常只考虑那些对新设备开放的 PAN（换句话说，它们许可加入），设备不得永久地竖立 **permitJoining** 标志，否则可能会导致公共配置文件和制造商特定的配置文件（MSPs）的 Zigbee PRO 合规性测试失败。因此，当需要将新设备添加到网络时，设备（尤其是 PAN 协调器）必须确保它们能够在本地启用 **permitJoining** 标志至少一段有限的时间。这种启用通常必须来自某些外部刺激，这取决于设备的物理能力。设备可以使用按钮或串行接口，这通常是启用 **permitJoining** 的一个适当刺激。然而，如果设备没有外部输入作为此刺激，则必须考虑其他方法。一种可能性是在首次启动时让设备启用 **permitJoining** 一段有限的时间。另一种选择是当节点通过无线接收到特定消息时启用 **permitJoining**。

关于后一种方法，应用程序可以通过本地调用 **emberPermitJoining()** API 或 **permitJoining** EZSP 命令来对其自己的 **permitJoining** 状态进行本地更改；也可以通过 ZDO（Zigbee 设备对象，本质上由栈实现）发送一个标准请求到 Zigbee 节点以请求其更改其 **permitJoining** 状态。

当应用程序配置文件 0x0000（Zigbee 设备配置文件）上的端点 0（ZDO）通过无线方式接收的 ZDO 许可加入请求时，栈会自动更改设备上的 **permitJoining** 状态。该请求的单播或广播提供了一种标准方式，以分别远程更改一些或所有设备的网络加入许可。有关实现此请求的示例代码，请参阅您的 EmberZNet PRO 安装中的 “**app/util/zigbee-framework/zigbee-device-common.h**” 文件中的 **emberPermitJoiningRequest()** API。

一旦网络包含许可加入的加入设备范围内的至少一个节点，加入设备应该能够通过栈原生的 **emberNetworkFoundHandler()/ezspNetworkFoundHandler()** 回调或通过其他在 **app/util/common/form-and-join.h** 中找到的 form-and-join 实用工具提供的 **emberJoinableNetworkFoundHandler()** 回调（通过 AFV2 架构使用）将其检测为可加入。（有关建议的实施，请参阅 AFV2 的 “Network Find” 插件或 “Network Steering” 插件）

